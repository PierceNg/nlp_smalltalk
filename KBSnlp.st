Object subclass: #NLPcategories	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'KBSnlp'!!NLPcategories commentStamp: '<historical>' prior: 0!A NLPcategories is class to categorize text.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NLPcategories class	instanceVariableNames: ''!!NLPcategories class methodsFor: 'classify' stamp: 'MarkWatson 1/13/2015 14:09'!classify: text	"classify text in a string"	| tokens categories scores num hash numTokens results cutoff |	tokens :=  NLPtagger tokenize: (text , 'XXXXXX').	categories := (Smalltalk at: #NlpCategoryHash) keys.	num := categories size.	numTokens := tokens size - 1.	scores := Array new: num.	1 to: num do: [ :i |		scores at: i put: 0.		hash := (Smalltalk at: #NlpCategoryHash) at: (categories at: i).		1 to: numTokens do: [ :j |			(hash includesKey: (tokens at: j))			  ifTrue: [scores at: i put: ((scores at: i) + (hash at: (tokens at: j)))] ].		hash := (Smalltalk at: #NlpCategory2gramHash) at: (categories at: i).		1 to: numTokens do: [ :j |			(hash includesKey: ((tokens at: j) , ' ' , (tokens at: j + 1)))			  ifTrue: [scores at: i put: ((scores at: i)+ ((hash at: (tokens at: j) , ' ' , (tokens at: j + 1)) * 8))]]].	results := SortedCollection sortBlock: [:c1 :c2 | (c1 at:1) > (c2 at:1)]. 	1 to: num do: [ :i | |a| a := (Array new: 2). a at: 1 put: (scores at:i); at: 2 put: (categories at: i). results add: a ].	cutoff := ((results at: 1) at: 1) / 2.	results := results select: [ :x | (x at: 1) > cutoff ].	^results.	! !!NLPcategories class methodsFor: 'classify' stamp: 'MarkWatson 1/13/2015 13:59'!initializeCategoryHash	"requires NeoJSON"     Smalltalk at: #NlpCategoryHash                    put: (NeoJSONReader fromString: (FileStream fileNamed: './nlp_smalltalk/tags.json') contentsOfEntireFile).     Smalltalk at: #NlpCategory2gramHash                    put: (NeoJSONReader fromString: (FileStream fileNamed: './nlp_smalltalk/tags_2gram.json') contentsOfEntireFile)! !Object subclass: #NLPentities	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'KBSnlp'!!NLPentities commentStamp: '<historical>' prior: 0!A NLPentities is a class to find people's names, company names, place names, etc. in text.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NLPentities class	instanceVariableNames: ''!!NLPentities class methodsFor: 'entityDetection' stamp: 'MarkWatson 1/13/2015 10:32'!entities: aString	"return a Dictionary of entities (keys type, values Sets"	| temp result |	result := Dictionary new.	temp := NLPentities entityHelper: (Smalltalk at: #NLPcompanyNames) text: aString.	temp size > 0		ifTrue: [ result at: 'companies' put: temp ].	temp := NLPentities entityHelper: (Smalltalk at: #NLPproductNames) text: aString.	temp size > 0		ifTrue: [ result at: 'products' put: temp ].	temp := NLPentities entityHelper: (Smalltalk at: #NLPplaceNames) text: aString.	temp size > 0		ifTrue: [ result at: 'places' put: temp ].	temp := NLPentities humanNameHelper: aString.	temp size > 0		ifTrue: [ result at: 'places' put: temp ].	^ result! !!NLPentities class methodsFor: 'entityDetection' stamp: 'MarkWatson 1/13/2015 10:32'!humanNameHelper: aString	"this is a helper method for everything **but** person names"	| tokens num results |	results := Set new.	tokens := NLPtagger tokenize: aString , ' xxxxx yyyyy zzzzz'.	num := tokens size - 3.	" account for the 3 fake tokens at the end "	1 to: num do: [ :i | 		((Smalltalk at: #NLPfirstNames) includes: (tokens at: i))			ifTrue: [ 				(((Smalltalk at: #NLPfirstNames) includes: (tokens at: i + 1))					and: ((Smalltalk at: #NLPlastNames) includes: (tokens at: i + 2)))					ifTrue: [ 						results add: (tokens at: i) , ' ' , (tokens at: i + 1) , ' ' , (tokens at: i + 2).						i := i + 2 ]					ifFalse: [ 						((Smalltalk at: #NLPlastNames) includes: (tokens at: i + 1))							ifTrue: [ 								results add: (tokens at: i) , ' ' , (tokens at: i + 1).								i := i + 1 ] ] ] ].	^ results! !!NLPentities class methodsFor: 'entityDetection' stamp: 'MarkWatson 1/13/2015 10:33'!entityHelper: entitySet text: aString	"this is a helper method for everything **but** person names"	| tokens num ngram2 ngram3 results |	results := Set new.	tokens := NLPtagger tokenize: aString , ' xxxxx yyyyy zzzzz'.	num := tokens size - 3.	" account for the 3 fake tokens at the end "	1 to: num do: [ :i | 		ngram2 := (tokens at: i) , ' ' , (tokens at: i + 1).		ngram3 := ngram2 , ' ' , (tokens at: i + 2).	"Transcript show: ngram2; cr."		(entitySet includes: ngram3)			ifTrue: [ results add: ngram3 ]			ifFalse: [ 				(entitySet includes: ngram2)					ifTrue: [ results add: ngram2 ]					ifFalse: [ 						(entitySet includes: (tokens at: i))							ifTrue: [ results add: (tokens at: i) ] ] ] ].	^ results! !!NLPentities class methodsFor: 'entityDetection' stamp: 'MarkWatson 1/12/2015 15:43'!fileToDictionary: filePath	"Read data/lexicon.txt and build in memory lexicon"      | read count  aLine  strm  set |      Transcript show: 'Processing file ' , filePath; cr.	set := Set new.	read := (MultiByteFileStream fileNamed: filePath) readOnly.	count := 0.	[read atEnd]		whileFalse: [count := count + 1.			aLine := read upTo: Character lf.	"Mac: use lf, Windows: use cr ???"			"look for a space character: "			((aLine indexOf: $:) > 0)			  ifTrue: [ 				 strm := ReadStream on: aLine.			       aLine := strm upTo: $:].			set add: aLine].	read close.	^set! !!NLPentities class methodsFor: 'entityDetection' stamp: 'MarkWatson 1/13/2015 10:33'!initializeEntities	"load entity name data"	" Note: place name lines of the form: Cairo:country_capital   Fixed in fileToDictionary "	Smalltalk at: #NLPcompanyNames put: (NLPentities fileToDictionary: './nlp_smalltalk/company_names.txt').	Smalltalk at: #NLPfirstNames put: (NLPentities fileToDictionary: './nlp_smalltalk/firstnames.txt').	Smalltalk at: #NLPlastNames put: (NLPentities fileToDictionary: './nlp_smalltalk/lastnames.txt').	Smalltalk at: #NLPhonorifics put: (NLPentities fileToDictionary: './nlp_smalltalk/honorifics.txt').	Smalltalk at: #NLPprefixNames put: (NLPentities fileToDictionary: './nlp_smalltalk/prefixnames.txt').	Smalltalk at: #NLPplaceNames put: (NLPentities fileToDictionary: './nlp_smalltalk/placenames.txt').	Smalltalk at: #NLPproductNames put: (NLPentities fileToDictionary: './nlp_smalltalk/product_names.txt')! !Object subclass: #NLPtagger	instanceVariableNames: ''	classVariableNames: 'NLPlexicon'	poolDictionaries: ''	category: 'KBSnlp'!!NLPtagger commentStamp: 'MW 1/27/2008 12:20' prior: 0!NLP tagger converted to Squeak.Copyring 2000-2008 Mark Watson. All rights reserved.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NLPtagger class	instanceVariableNames: ''!!NLPtagger class methodsFor: 'segmentation' stamp: 'MarkWatson 5/14/2017 14:25'!sentences: data	"Handle either a string or array of tokens"	| tokens currentSentence allSentences |	tokens := (data isMemberOf: ByteString)		ifTrue: (NLPtagger tokenize: data)		ifFalse: data.	currentSentence := OrderedCollection new.	allSentences := OrderedCollection new.	Transcript		show: tokens;		cr.	tokens		do: [ :token | 			Transcript				show: token;				cr.			currentSentence add: token.			token = '.' | (token = '?')				ifTrue: [ allSentences addLast: currentSentence.					currentSentence := OrderedCollection new ] ].	currentSentence isNotEmpty 		ifTrue: [ allSentences addLast: currentSentence ].	^ allSentences! !!NLPtagger class methodsFor: 'tagging' stamp: 'MarkWatson 1/12/2015 14:55'!tokenize: wordsInAString 	"tokenizes a string"	^wordsInAString findTokens: ' ;:.,<>[]{}!!@#$%^&*()?' keep: ';:.,<>[]{}!!$'   " keep CR in this string!!!! "! !!NLPtagger class methodsFor: 'tagging' stamp: 'MW 1/27/2008 12:53'!tag: words	"tag an ordered collection of words, returning an ordered collection of corresponding tags"	| lex tags tag count i word lastWord lastTag |	tags := OrderedCollection new.	lex := Smalltalk at: #NLPlexicon.	words do: 			[:aWord | 			tag := lex at: aWord ifAbsent: [nil].			tag isNil ifFalse: [tag := tag at: 1] ifTrue: [tag := 'NN'].	" the default tag "			tags add: tag].	" Apply transformation rules: "	lastWord := ''.	lastTag := ''.	i := 0.	count := words size.	[i < count] whileTrue: 			[i := i + 1.			word := words at: i.			tag := tags at: i.	" reuse tag variable "			" First, handle all rules for i &gt; 1 "			i > 1 				ifTrue: 					[" rule 1: DT, {VBD | VBP} --> DT, NN "					lastTag = 'DT' & (tag = 'VBD' | (tag = 'VBP') | (tag = 'VB')) 						ifTrue: [tags at: i put: 'NN'].					tag size > 1 						ifTrue: 							[" rule 6: convert a noun to a verb if the preceeding work is 'would' "							(tag at: 1) = $N & ((tag at: 2) = $N) & (lastWord asLowercase = 'would') 								ifTrue: [tags at: i put: 'VB']]].			" Now, handle the remaining rules that are valid for i = 1: "			" rule 2: convert a noun to a number (CD) if '.' appears in the word"			(word findString: '.') > 0 				ifTrue: [(tag at: 1) = $N ifTrue: [tags at: i put: 'CD']].	" not working - tokenizer tosses '.' characters "			" rule 3: convert a noun to a past participle if words[i] ends with 'ed' "			(tag at: 1) = $N & (word endsWith: 'ed') ifTrue: [tags at: i put: 'VBN'].			" rule 4: convert any type to adverb if it ends in 'ly' "			(word endsWith: 'ly') ifTrue: [tags at: i put: 'RB'].			" rule 5: convert a common noun (NN or NNS) to a adjective if it ends with 'al' "			(tag at: 1) = $N & (word endsWith: 'al') ifTrue: [tags at: i put: 'JJ'].			" rule 7: if a word has been categorized as a common noun and it ends with 's;, "			"          then set its type to plural common noun (NNS) "			tag = 'NN' & (word endsWith: 's') ifTrue: [tags at: i put: 'NNS'].			" rule 8: convert a common noun to a present prticiple verb (i.e., a gerand) "			(tag at: 1) = $N & (word endsWith: 'ing') ifTrue: [tags at: i put: 'VBG'].			lastWord := word.			lastTag := tag].	^tags! !!NLPtagger class methodsFor: 'tagging' stamp: 'MW 1/27/2008 12:50'!initializeLexicon	"Read data/lexicon.txt and build in memory lexicon"	| read count strm aLine word taglist token lex |	lex := Dictionary new.	read := (FileStream fileNamed: './nlp_smalltalk/lexicon.txt') readOnly.	count := 0.	[read atEnd]		whileFalse: [count := count + 1.			aLine := read upTo: Character lf.	"Mac: use lf, Windows: use cr ???"			strm := ReadStream on: aLine.			word := strm upTo: Character space.			taglist := OrderedCollection new.			[strm atEnd]				whileFalse: [token := strm upTo: Character space.					taglist add: token].			"Transcript show: word; cr."			"Transcript show: taglist printString; cr."			lex at: word put: taglist].	read close.	lex inspect.	Smalltalk at: #NLPlexicon put: lex! !!NLPtagger class methodsFor: 'tagging' stamp: 'MW 1/27/2008 13:21'!pptag: wordString 	"returns a string of word/tag ..."	| words tags write size count |	words := NLPtagger tokenize: wordString.	tags := NLPtagger tag: words.	write := TextStream on: String new.	size := words size.	count := 1.	[count <= size]		whileTrue: [			write nextPutAll: (words at: count).			write nextPutAll: '/'.			write nextPutAll: (tags at: count).			write nextPutAll: ' '.			count := count + 1].	^write contents string! !